<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sql on Aurora</title><link>https://notes.yoooo.fun/tags/sql/</link><description>Recent content in Sql on Aurora</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 23 Jun 2020 09:17:37 +0000</lastBuildDate><atom:link href="https://notes.yoooo.fun/tags/sql/index.xml" rel="self" type="application/rss+xml"/><item><title>delete, truncate and drop</title><link>https://notes.yoooo.fun/posts/db-del-trunc-drop/</link><pubDate>Tue, 23 Jun 2020 08:57:45 +0000</pubDate><guid>https://notes.yoooo.fun/posts/db-del-trunc-drop/</guid><description>&lt;h1 id="delete-truncate-drop"&gt;delete truncate drop
&lt;/h1&gt;&lt;h2 id="delete"&gt;delete
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;delete是 &lt;code&gt;DML&lt;/code&gt; ，执行delete操作时，每次从表中删除一行，并且同时将该行的的删除操作记录在redo和undo表空间中以便进行回滚（rollback）和重做操作，但要注意表空间要足够大，需要手动提交（commit）操作才能生效，可以通过rollback撤消操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delete可根据条件删除表中满足条件的数据，如果不指定where子句，那么删除表中所有记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delete语句不影响表所占用的extent，高水线(high watermark)保持原位置不变。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="truncate"&gt;truncate
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;truncate是 &lt;code&gt;DDL&lt;/code&gt; ，会隐式提交，所以，不能回滚，不会触发触发器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;truncate会删除表中所有记录，并且将重新设置高水线和所有的索引，缺省情况下将空间释放到minextents个extent，除非使用reuse
storage，。不会记录日志，所以执行速度很快，但不能通过rollback撤消操作（如果一不小心把一个表truncate掉，也是可以恢复的，只是不能通过rollback来恢复）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于外键（foreignkey ）约束引用的表，不能使用 truncate table，而应使用不带 where 子句的 delete 语句。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;truncate table不能用于参与了索引视图的表。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="drop"&gt;drop
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;drop是 &lt;code&gt;DDL&lt;/code&gt; ，会隐式提交，所以，不能回滚，不会触发触发器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;drop语句删除表结构及所有数据，并将表所占用的空间全部释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;drop语句将删除表的结构所依赖的约束，触发器，索引，依赖于该表的存储过程/函数将保留,但是变为invalid状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="总结"&gt;总结
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在速度上，一般来说，drop&amp;gt; truncate &amp;gt; delete。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在使用drop和truncate时一定要注意，虽然可以恢复，但为了减少麻烦，还是要慎重。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果想删除部分数据用delete，注意带上where子句，回滚段要足够大；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果想删除表，当然用drop；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果想保留表而将所有数据删除，如果和事务无关，用truncate即可；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果和事务有关，或者想触发trigger，还是用delete；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>